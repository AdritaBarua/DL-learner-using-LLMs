We can look for a property that all the positive examples have in common but that the negatives lack. In this ontology many individuals have parent–child relationships. Observe that:

• Every positive individual (kb:Luigi, kb:Maria, kb:Dino, kb:Serena, kb:Ombretta, kb:Luca) is recorded as being a child (i.e. there is at least one statement showing “X has a relationship kb:hasParent …”). For example:
 – kb:Luigi has kb:hasParent kb:Maria (and also with kb:Dino);
 – kb:Maria has kb:hasParent kb:Gianni and kb:hasParent kb:Dora;
 – kb:Dino has kb:hasParent kb:NonnoLuigi (and via the inverse of kb:hasChild from kb:NonnaLina);
 – kb:Serena appears (via kb:hasChild assertions made by kb:Maria or kb:Dino) as having a parent;
 – kb:Ombretta likewise has a parent (from kb:Maria and kb:Dino);
 – kb:Luca has kb:hasParent kb:Luciano (and also via kb:Lucrezia hasChild kb:Luca).

• In contrast, neither of the negative examples (kb:Dora and kb:Gianni) is ever given a “hasParent” relationship. (They appear only as parents.)

A simple complex class expression that “captures” being a child is to say that an individual is a Person and that it has at least one parent (i.e. it is in the filler of the kb:hasParent property). In Manchester syntax we can write this as follows:

  kb:Person and (kb:hasParent some kb:Person)

This expression is true of every positive example (each one has a kb:hasParent relation to some Person) but false for kb:Dora and kb:Gianni (since no kb:hasParent triple is asserted for them).

Thus, one acceptable complex class expression is:

  kb:Person and (kb:hasParent some kb:Person)