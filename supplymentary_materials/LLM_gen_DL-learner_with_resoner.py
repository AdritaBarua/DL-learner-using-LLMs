#gpt-4o family
import os
import subprocess
import openai
import time

from openai import OpenAI

# Initialize OpenAI client
client = OpenAI(api_key="your api key")

log_file = "debug_log.txt"
if os.path.isdir(log_file):
    os.rmdir(log_file)

def log_message(message: str):
    with open(log_file, "a", encoding="utf‑8") as f:
        f.write(message + "\n")
    print(message)

def read_text_file(path: str) -> str:
    with open(path, "r", encoding="utf‑8") as f:
        return f.read().strip()

def ask_question(prompt: str) -> str:
    start_time = time.time()  # Record start time
    resp = client.chat.completions.create(
        model="gpt-4o",
        #messages=[{"role": "user", "content": prompt}],
        messages=[
            {"role": "system", "content": "You are a helpful Description Logic learner."},
            {"role": "user",   "content": prompt}
        ],
        temperature=0,
        top_p=1
    )
    end_time = time.time()  # Record end time
    processing_time = end_time - start_time  # Calculate processing time
    text = resp.choices[0].message.content.strip()
    log_message(f"\nLLM ➤ {text}")
    # Print the processing time
    print(f"Processing time for gpt-4o: {processing_time:.2f} seconds")  
    return text, processing_time


def closed_world_reasoner(
    llm_block: str,
    kb_file: str,
    base_iri: str,
    pos_list: str,
    neg_list: str
):
    """
    Calls your GenericReasonerCheck jar-with-dependencies using Pellet.
    - llm_block: the full multiline LLM output (lines “1: …” through “5: …”)
    - pos_list, neg_list: comma-separated names
    Returns (valid: bool, feedback: str).
    """
    cmd = [
        "java", "-jar",
        "target/merged-reasoner-check-1.0-SNAPSHOT.jar",
        kb_file,
        base_iri,
        "-",            # read the LLM block from stdin
        pos_list,
        neg_list
    ]
    log_message(f"\n▶ Running Pellet: {' '.join(cmd)}")
    proc = subprocess.run(
        cmd,
        input=llm_block,
        capture_output=True,
        text=True
    )
    out = proc.stdout.strip()
    err = proc.stderr.strip()
    if out:
        log_message(f"Pellet stdout ➤\n{out}")
    if err:
        log_message(f"Pellet stderr ➤\n{err}")

    #valid = (proc.returncode == 0)
    #feedback = out if out else err
    valid = (proc.returncode == 0)
     # always include both streams
    feedback_parts = []
    if out:
        feedback_parts.append(out)
    if err:
        feedback_parts.append(err)
    feedback = "\n".join(feedback_parts)

    return valid, feedback

def process_files(positive_folder, negative_folder, output_folder, kb_file, kb_file_text):
    kb_text = read_text_file(kb_file_text)

    for fname in sorted(os.listdir(positive_folder)):
        if not fname.startswith("positive_") or not fname.endswith(".txt"):
            continue
        base = fname[len("positive_"):-4]
        pos_path = os.path.join(positive_folder, fname)
        neg_path = os.path.join(negative_folder, f"negative_{base}.txt")
        if not os.path.exists(neg_path):
            continue

        # Read and clean up names for Java
        pos_names = [ln.replace("kb:", "").strip()
                     for ln in read_text_file(pos_path).splitlines() if ln.strip()]
        neg_names = [ln.replace("kb:", "").strip()
                     for ln in read_text_file(neg_path).splitlines() if ln.strip()]
        pos_arg = ",".join(pos_names)
        neg_arg = ",".join(neg_names)

        print(f"\n=== Processing batch: {base} ===")
        base_iri = input("Enter your base IRI (e.g. http://example.org/onto#): ").strip()
        if not (base_iri.endswith("#") or base_iri.endswith("/")):
            base_iri += "#"

        attempts = 0
        max_attempts = 3
        valid = False
        feedback = ""
        llm_block = ""
        processing_time = 0.0

        while attempts < max_attempts and not valid:
            prompt = f"""
Take the given ontology as the knowledge base: {kb_text}.

Use this knowledge base to extract complex class expressions for the given positive and negative examples. A complex class expression is an OWL class expression that consists of the classes and properties that apply to the positive examples but not to the negative examples.
Use Manchester syntax for the complex class expressions. 
For example:
If the positive examples are:
(Dino, Luigi, Mauro, Francesco, Giuseppe)

And the negative examples are:
(Antonella, Giovanna, Maria, Marisella, Milly, Nella, NonnaLina, Ombretta, Rosanna, Serena, Valentina, Luca)

Then the complex class expression generated by DL-Learner is(first 5 are shown):
1: Male and (hasSibling some Thing) (accuracy 100%, length 5, depth 1)
2: Male and ((not (Male)) or (hasSibling some Thing)) (accuracy 100%, length 8, depth 1)
3: Male and ((hasChild some Thing) or (hasSibling some Thing)) (accuracy 100%, length 9, depth 1)
4: Male and ((hasSibling some Thing) or (hasSibling some Thing)) (accuracy 100%, length 9, depth 1)
5: Male and ((hasSibling some Thing) or (hasParent max 1 Thing)) (accuracy 100%, length 10, depth 1)

All the class expressions are generated using the Closed World Assumption of the knowledge base.

Now, perform a logical reasoning based on the knowledge base to find the shortest complex class expressions for the following examples:

Positive examples: {pos_arg}
Negative examples: {neg_arg}
{feedback} 
Don't give me any description just the shortest complex class expressions(upto first 5) and follow the example format:
"""
            #Generate the complex class expression for {base}.
            llm_block, processing_time = ask_question(prompt)
            valid, reason = closed_world_reasoner(
                llm_block, kb_file, base_iri, pos_arg, neg_arg
            )
            log_message(f"Validation result ➤ valid={valid}, feedback:\n{reason}")
            if not valid:
                feedback = f"Previous attempt:\n{llm_block}\nReasoner output:\n{reason}\nPlease refine based on the Reasoner feedback."
                log_message(f"Reasoner feedback:\n{feedback}")
            attempts += 1

        # Save final LLM block + reasoner output
        out_path = os.path.join(output_folder, f"response_{base}.txt")
        with open(out_path, "w", encoding="utf-8") as f:
            if valid:
                f.write("✅ SUCCESS on attempt {}\n\n".format(attempts))
                f.write("LLM output:\n" + llm_block + "\n\n")
                f.write("Reasoner feedback:\n" + reason + "\n")
                f.write(f"\nProcessing time for gpt-4o: {processing_time:.2f} seconds\n")  # Save the processing time in the output file
            else:
                f.write("❌ All {} attempts were invalid.\n\n".format(max_attempts))
                f.write("Last LLM output:\n" + llm_block + "\n\n")
                f.write("Last reasoner feedback:\n" + reason + "\n")
                f.write(f"\nProcessing time for gpt-4o: {processing_time:.2f} seconds\n")  # Save the processing time in the output file
        log_message(f"\n✔ Saved final batch to {out_path}\n")

        
        
if __name__ == "__main__":
    positive_folder   = "yinyang_examples/positive"
    negative_folder   = "yinyang_examples/negative"
    output_folder     = "yinyang_examples/responses_with_reasoner_without_basename"
    kb_file           = "yinyang_examples/basicFamily.owl"
    kb_file_text      = "yinyang_examples/KB_family.txt"

    os.makedirs(output_folder, exist_ok=True)
    process_files(
        positive_folder,
        negative_folder,
        output_folder,
        kb_file,
        kb_file_text
    )

#gpt-4o family benchmark
import os
import subprocess
import openai
import time

from openai import OpenAI

# Initialize OpenAI client
client = OpenAI(api_key="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")

log_file = "debug_log.txt"
if os.path.isdir(log_file):
    os.rmdir(log_file)

def log_message(message: str):
    with open(log_file, "a", encoding="utf‑8") as f:
        f.write(message + "\n")
    print(message)

def read_text_file(path: str) -> str:
    with open(path, "r", encoding="utf‑8") as f:
        return f.read().strip()

def ask_question(prompt: str) -> str:
    start_time = time.time()  # Record start time
    resp = client.chat.completions.create(
        model="gpt-4o",
        #messages=[{"role": "user", "content": prompt}],
        messages=[
            {"role": "system", "content": "You are a helpful Description Logic learner."},
            {"role": "user",   "content": prompt}
        ],
        temperature=0,
        top_p=1
    )
    end_time = time.time()  # Record end time
    processing_time = end_time - start_time  # Calculate processing time
    text = resp.choices[0].message.content.strip()
    log_message(f"\nLLM ➤ {text}")
    # Print the processing time
    print(f"Processing time for gpt-4o: {processing_time:.2f} seconds")  
    return text, processing_time


def closed_world_reasoner(
    llm_block: str,
    kb_file: str,
    base_iri: str,
    pos_list: str,
    neg_list: str
):
    """
    Calls your GenericReasonerCheck jar-with-dependencies using Pellet.
    - llm_block: the full multiline LLM output (lines “1: …” through “5: …”)
    - pos_list, neg_list: comma-separated names
    Returns (valid: bool, feedback: str).
    """
    cmd = [
        "java", "-jar",
        "target/merged-reasoner-check-1.0-SNAPSHOT.jar",
        kb_file,
        base_iri,
        "-",            # read the LLM block from stdin
        pos_list,
        neg_list
    ]
    log_message(f"\n▶ Running Pellet: {' '.join(cmd)}")
    proc = subprocess.run(
        cmd,
        input=llm_block,
        capture_output=True,
        text=True
    )
    out = proc.stdout.strip()
    err = proc.stderr.strip()
    if out:
        log_message(f"Pellet stdout ➤\n{out}")
    if err:
        log_message(f"Pellet stderr ➤\n{err}")

    #valid = (proc.returncode == 0)
    #feedback = out if out else err
    valid = (proc.returncode == 0)
     # always include both streams
    feedback_parts = []
    if out:
        feedback_parts.append(out)
    if err:
        feedback_parts.append(err)
    feedback = "\n".join(feedback_parts)

    return valid, feedback

def process_files(positive_folder, negative_folder, output_folder, kb_file, kb_file_text):
    kb_text = read_text_file(kb_file_text)

    for fname in sorted(os.listdir(positive_folder)):
        if not fname.startswith("positive_") or not fname.endswith(".txt"):
            continue
        base = fname[len("positive_"):-4]
        pos_path = os.path.join(positive_folder, fname)
        neg_path = os.path.join(negative_folder, f"negative_{base}.txt")
        if not os.path.exists(neg_path):
            continue
        
        # Read and clean up names for Java, stripping either 'kb:' or 'ex:' prefixes
        pos_names = [
            ln.strip()
              .replace("kb:", "")
              .replace("ex:", "")
            for ln in read_text_file(pos_path).splitlines()
            if ln.strip()
        ]
        neg_names = [
            ln.strip()
              .replace("kb:", "")
              .replace("ex:", "")
            for ln in read_text_file(neg_path).splitlines()
            if ln.strip()
        ]

        pos_arg = ",".join(pos_names)
        neg_arg = ",".join(neg_names)


        print(f"\n=== Processing batch: {base} ===")
        base_iri = input("Enter your base IRI (e.g. http://example.org/onto#): ").strip()
        if not (base_iri.endswith("#") or base_iri.endswith("/")):
            base_iri += "#"

        attempts = 0
        max_attempts = 3
        valid = False
        feedback = ""
        llm_block = ""
        processing_time = 0.0

        while attempts < max_attempts and not valid:
            prompt = f"""
Take the given ontology as the knowledge base: {kb_text}.

Use this knowledge base to extract complex class expressions for the given positive and negative examples. A complex class expression is an OWL class expression that consists of the classes and properties that apply to the positive examples but not to the negative examples.
Use Manchester syntax for the complex class expressions. 
For example:
If the positive examples are:
(F2M13, F2M18, F2M11, F2M32, F3M44, F3M45, F5M64, F6M71, F6M81, F6M90, F6M100, F6M92, F7M113, F7M117, F7M115, F7M125, F7M123, F7M131, F9M151, F9M153, F9M159, F9M166, F9M162, F9M157, F9M167, F10M173, F10M183, F10M184, F10M188, F10M199)

And the negative examples are:
(F10M196, F1M8, F7F103, F3F41, F1M1, F9F164, F9M149, F9M147, F9F158, F2F12, F1F5, F6M88, F7M104, F7M109, F7M120, F6F83, F6M78, F3M47, F10F174, F6F76, F2F26, F6F89, F3M50, F3F42, F6F79, F10M194, F2F19, F2F24, F9F154, F4F58)

Then the complex class expression generated by DL-Learner is(first 5 are shown):
1: Male and (hasSibling some Thing) (pred. acc.: 100.00%, F-measure: 100.00%)
2: Male and (hasParent some Thing) (pred. acc.: 95.00%, F-measure: 95.24%)
3: Male (pred. acc.: 80.00%, F-measure: 83.33%)
4: not (Female) (pred. acc.: 80.00%, F-measure: 83.33%)
5: Person and (not (Female)) (pred. acc.: 80.00%, F-measure: 83.33%)

All the class expressions are generated using the Closed World Assumption of the knowledge base.

Now, perform a logical reasoning based on the knowledge base to find the shortest complex class expressions for the following examples:

Positive examples: {pos_arg}
Negative examples: {neg_arg}
Generate the complex class expression for {base}.
{feedback} 
Don't give me any description just the shortest complex class expressions(upto first 5) and follow the example format:
"""
            #Generate the complex class expression for {base}.
            llm_block, processing_time = ask_question(prompt)
            valid, reason = closed_world_reasoner(
                llm_block, kb_file, base_iri, pos_arg, neg_arg
            )
            log_message(f"Validation result ➤ valid={valid}, feedback:\n{reason}")
            if not valid:
                feedback = f"Previous attempt:\n{llm_block}\nReasoner output:\n{reason}\nPlease refine based on the Reasoner feedback."
                log_message(f"Reasoner feedback:\n{feedback}")
            attempts += 1

        # Save final LLM block + reasoner output
        out_path = os.path.join(output_folder, f"response_{base}.txt")
        with open(out_path, "w", encoding="utf-8") as f:
            if valid:
                f.write("✅ SUCCESS on attempt {}\n\n".format(attempts))
                f.write("LLM output:\n" + llm_block + "\n\n")
                f.write("Reasoner feedback:\n" + reason + "\n")
                f.write(f"\nProcessing time for gpt-4o: {processing_time:.2f} seconds\n")  # Save the processing time in the output file
            else:
                f.write("❌ All {} attempts were invalid.\n\n".format(max_attempts))
                f.write("Last LLM output:\n" + llm_block + "\n\n")
                f.write("Last reasoner feedback:\n" + reason + "\n")
                f.write(f"\nProcessing time for gpt-4o: {processing_time:.2f} seconds\n")  # Save the processing time in the output file
        log_message(f"\n✔ Saved final batch to {out_path}\n")

        
        
if __name__ == "__main__":
    positive_folder   = "family-benchmark/positive"
    negative_folder   = "family-benchmark/negative"
    output_folder     = "family-benchmark/responses_with_reasoner"
    kb_file           = "family-benchmark/family-benchmark.owl"
    kb_file_text      = "family-benchmark/KB_family-benchmark.txt"

    os.makedirs(output_folder, exist_ok=True)
    process_files(
        positive_folder,
        negative_folder,
        output_folder,
        kb_file,
        kb_file_text
    )


# In[30]:


#gpt-4o trains2
import os
import subprocess
import openai
import time

from openai import OpenAI

# Initialize OpenAI client
client = OpenAI(api_key="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")

log_file = "debug_log.txt"
if os.path.isdir(log_file):
    os.rmdir(log_file)

def log_message(message: str):
    with open(log_file, "a", encoding="utf‑8") as f:
        f.write(message + "\n")
    print(message)

def read_text_file(path: str) -> str:
    with open(path, "r", encoding="utf‑8") as f:
        return f.read().strip()

def ask_question(prompt: str) -> str:
    start_time = time.time()  # Record start time
    resp = client.chat.completions.create(
        model="gpt-4o",
        #messages=[{"role": "user", "content": prompt}],
        messages=[
            {"role": "system", "content": "You are a helpful Description Logic learner."},
            {"role": "user",   "content": prompt}
        ],
        temperature=0,
        top_p=1
    )
    end_time = time.time()  # Record end time
    processing_time = end_time - start_time  # Calculate processing time
    text = resp.choices[0].message.content.strip()
    log_message(f"\nLLM ➤ {text}")
    # Print the processing time
    print(f"Processing time for gpt-4o: {processing_time:.2f} seconds")  
    return text, processing_time


def closed_world_reasoner(
    llm_block: str,
    kb_file: str,
    base_iri: str,
    pos_list: str,
    neg_list: str
):
    """
    Calls your GenericReasonerCheck jar-with-dependencies using Pellet.
    - llm_block: the full multiline LLM output (lines “1: …” through “5: …”)
    - pos_list, neg_list: comma-separated names
    Returns (valid: bool, feedback: str).
    """
    cmd = [
        "java", "-jar",
        "target/merged-reasoner-check-1.0-SNAPSHOT.jar",
        kb_file,
        base_iri,
        "-",            # read the LLM block from stdin
        pos_list,
        neg_list
    ]
    log_message(f"\n▶ Running Pellet: {' '.join(cmd)}")
    proc = subprocess.run(
        cmd,
        input=llm_block,
        capture_output=True,
        text=True
    )
    out = proc.stdout.strip()
    err = proc.stderr.strip()
    if out:
        log_message(f"Pellet stdout ➤\n{out}")
    if err:
        log_message(f"Pellet stderr ➤\n{err}")

    #valid = (proc.returncode == 0)
    #feedback = out if out else err
    valid = (proc.returncode == 0)
     # always include both streams
    feedback_parts = []
    if out:
        feedback_parts.append(out)
    if err:
        feedback_parts.append(err)
    feedback = "\n".join(feedback_parts)

    return valid, feedback

def process_files(positive_folder, negative_folder, output_folder, kb_file, kb_file_text):
    kb_text = read_text_file(kb_file_text)

    for fname in sorted(os.listdir(positive_folder)):
        if not fname.startswith("positive_") or not fname.endswith(".txt"):
            continue
        base = fname[len("positive_"):-4]
        pos_path = os.path.join(positive_folder, fname)
        neg_path = os.path.join(negative_folder, f"negative_{base}.txt")
        if not os.path.exists(neg_path):
            continue

        # Read and clean up names for Java
        pos_names = [ln.replace("kb:", "").strip()
                     for ln in read_text_file(pos_path).splitlines() if ln.strip()]
        neg_names = [ln.replace("kb:", "").strip()
                     for ln in read_text_file(neg_path).splitlines() if ln.strip()]
        pos_arg = ",".join(pos_names)
        neg_arg = ",".join(neg_names)

        print(f"\n=== Processing batch: {base} ===")
        base_iri = input("Enter your base IRI (e.g. http://example.org/onto#): ").strip()
        if not (base_iri.endswith("#") or base_iri.endswith("/")):
            base_iri += "#"

        attempts = 0
        max_attempts = 3
        valid = False
        feedback = ""
        llm_block = ""
        processing_time = 0.0

        while attempts < max_attempts and not valid:
            prompt = f"""
Take the given ontology as the knowledge base: {kb_text}.

Use this knowledge base to extract complex class expressions for the given positive and negative examples. A complex class expression is an OWL class expression that consists of the classes and properties that apply to the positive examples but not to the negative examples.
Use Manchester syntax for the complex class expressions. 
For example:
If the positive examples are:
(east1, east2, east3, east4, east5)

And the negative examples are:
(west6, west7, west8, west9, west10)

Then the complex class expression generated by DL-Learner is(first 5 are shown):
1: hasCar some (ClosedCar and ShortCar) (accuracy 100%, length 5, depth 1)
2: Train and (hasCar some (ClosedCar and ShortCar)) (accuracy 100%, length 7, depth 1)
3: (not (ClosedCar)) and (hasCar some (ClosedCar and ShortCar)) (accuracy 100%, length 8, depth 1)
4: (not (DoubleCar)) and (hasCar some (ClosedCar and ShortCar)) (accuracy 100%, length 8, depth 1)
5: (not (JaggedCar)) and (hasCar some (ClosedCar and ShortCar)) (accuracy 100%, length 8, depth 1)

All the class expressions are generated using the Closed World Assumption of the knowledge base.

Now perform logical reasoning on the knowledge base to find the shortest complex class expressions for the following examples. A “shortest” class expression consists of the minimal set of classes for which the expression holds true.
Positive examples: {pos_arg}
Negative examples: {neg_arg}
{feedback} 
Don't give me any description just the shortest complex class expressions(upto first 5) and follow the example format:
"""
            llm_block, processing_time = ask_question(prompt)
            valid, reason = closed_world_reasoner(
                llm_block, kb_file, base_iri, pos_arg, neg_arg
            )
            log_message(f"Validation result ➤ valid={valid}, feedback:\n{reason}")
            if not valid:
                feedback = f"Previous attempt:\n{llm_block}\nReasoner output:\n{reason}\nPlease refine based on the Reasoner feedback."
                log_message(f"Reasoner feedback:\n{feedback}")
            attempts += 1

        # Save final LLM block + reasoner output
        out_path = os.path.join(output_folder, f"response_{base}.txt")
        with open(out_path, "w", encoding="utf-8") as f:
            if valid:
                f.write("✅ SUCCESS on attempt {}\n\n".format(attempts))
                f.write("LLM output:\n" + llm_block + "\n\n")
                f.write("Reasoner feedback:\n" + reason + "\n")
                f.write(f"\nProcessing time for gpt-4o: {processing_time:.2f} seconds\n")  # Save the processing time in the output file
            else:
                f.write("❌ All {} attempts were invalid.\n\n".format(max_attempts))
                f.write("Last LLM output:\n" + llm_block + "\n\n")
                f.write("Last reasoner feedback:\n" + reason + "\n")
                f.write(f"\nProcessing time for gpt-4o: {processing_time:.2f} seconds\n")  # Save the processing time in the output file
        log_message(f"\n✔ Saved final batch to {out_path}\n")

        
        
if __name__ == "__main__":
    positive_folder   = "trains/positive"
    negative_folder   = "trains/negative"
    output_folder     = "trains/responses_with_reasoner"
    kb_file           = "trains/trains2.owl"
    kb_file_text      = "trains/KB_trains2.txt"

    os.makedirs(output_folder, exist_ok=True)
    process_files(
        positive_folder,
        negative_folder,
        output_folder,
        kb_file,
        kb_file_text
    )


# In[27]:


#o3-mini trains
import os
import subprocess
import openai
import time

from openai import OpenAI

# Initialize OpenAI client
client = OpenAI(api_key="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")

log_file = "debug_log.txt"
if os.path.isdir(log_file):
    os.rmdir(log_file)

def log_message(message: str):
    with open(log_file, "a", encoding="utf‑8") as f:
        f.write(message + "\n")
    print(message)

def read_text_file(path: str) -> str:
    with open(path, "r", encoding="utf‑8") as f:
        return f.read().strip()
    
def ask_question(prompt: str) -> str:
    start_time = time.time()  # Record start time
    resp = client.chat.completions.create(
        model="o3-mini",
        reasoning_effort="high",
        #messages=[{"role": "user", "content": prompt}],
        messages=[
            {"role": "system", "content": "You are a helpful Description Logic learner."},
            {"role": "user",   "content": prompt}
        ],
        store=True,
    )
    end_time = time.time()  # Record end time
    processing_time = end_time - start_time  # Calculate processing time
    text = resp.choices[0].message.content.strip()
    log_message(f"\nLLM ➤ {text}")
    # Print the processing time
    print(f"Processing time for o3-mini: {processing_time:.2f} seconds")  
    return text, processing_time


def closed_world_reasoner(
    llm_block: str,
    kb_file: str,
    base_iri: str,
    pos_list: str,
    neg_list: str
):
    """
    Calls your GenericReasonerCheck jar-with-dependencies using Pellet.
    - llm_block: the full multiline LLM output (lines “1: …” through “5: …”)
    - pos_list, neg_list: comma-separated names
    Returns (valid: bool, feedback: str).
    """
    cmd = [
        "java", "-jar",
        "target/merged-reasoner-check-1.0-SNAPSHOT.jar",
        kb_file,
        base_iri,
        "-",            # read the LLM block from stdin
        pos_list,
        neg_list
    ]
    log_message(f"\n▶ Running Pellet: {' '.join(cmd)}")
    proc = subprocess.run(
        cmd,
        input=llm_block,
        capture_output=True,
        text=True
    )
    out = proc.stdout.strip()
    err = proc.stderr.strip()
    if out:
        log_message(f"Pellet stdout ➤\n{out}")
    if err:
        log_message(f"Pellet stderr ➤\n{err}")

    #valid = (proc.returncode == 0)
    #feedback = out if out else err
    valid = (proc.returncode == 0)
     # always include both streams
    feedback_parts = []
    if out:
        feedback_parts.append(out)
    if err:
        feedback_parts.append(err)
    feedback = "\n".join(feedback_parts)

    return valid, feedback

def process_files(positive_folder, negative_folder, output_folder, kb_file, kb_file_text):
    kb_text = read_text_file(kb_file_text)

    for fname in sorted(os.listdir(positive_folder)):
        if not fname.startswith("positive_") or not fname.endswith(".txt"):
            continue
        base = fname[len("positive_"):-4]
        pos_path = os.path.join(positive_folder, fname)
        neg_path = os.path.join(negative_folder, f"negative_{base}.txt")
        if not os.path.exists(neg_path):
            continue

        # Read and clean up names for Java
        pos_names = [ln.replace("kb:", "").strip()
                     for ln in read_text_file(pos_path).splitlines() if ln.strip()]
        neg_names = [ln.replace("kb:", "").strip()
                     for ln in read_text_file(neg_path).splitlines() if ln.strip()]
        pos_arg = ",".join(pos_names)
        neg_arg = ",".join(neg_names)

        print(f"\n=== Processing batch: {base} ===")
        base_iri = input("Enter your base IRI (e.g. http://example.org/onto#): ").strip()
        if not (base_iri.endswith("#") or base_iri.endswith("/")):
            base_iri += "#"

        attempts = 0
        max_attempts = 3
        valid = False
        feedback = ""
        llm_block = ""
        processing_time = 0.0

        while attempts < max_attempts and not valid:
            prompt = f"""
Take the given ontology as the knowledge base: {kb_text}.

Use this knowledge base to extract complex class expressions for the given positive and negative examples. A complex class expression is an OWL class expression that consists of the classes and properties that apply to the positive examples but not to the negative examples.
Use Manchester syntax for the complex class expressions. 
For example:
If the positive examples are:
(east1, east2, east3, east4, east5)

And the negative examples are:
(west6, west7, west8, west9, west10)

Then the complex class expression generated by DL-Learner is(first 5 are shown):
1: hasCar some (ClosedCar and ShortCar) (accuracy 100%, length 5, depth 1)
2: Train and (hasCar some (ClosedCar and ShortCar)) (accuracy 100%, length 7, depth 1)
3: (not (ClosedCar)) and (hasCar some (ClosedCar and ShortCar)) (accuracy 100%, length 8, depth 1)
4: (not (DoubleCar)) and (hasCar some (ClosedCar and ShortCar)) (accuracy 100%, length 8, depth 1)
5: (not (JaggedCar)) and (hasCar some (ClosedCar and ShortCar)) (accuracy 100%, length 8, depth 1)

All the class expressions are generated using the Closed World Assumption of the knowledge base.

Now perform logical reasoning on the knowledge base to find the shortest complex class expressions for the following examples. A “shortest” class expression consists of the minimal set of classes for which the expression holds true.
Positive examples: {pos_arg}
Negative examples: {neg_arg}
{feedback} 
Don't give me any description just the shortest complex class expressions(upto first 5) and follow the example format:
"""
            #Generate the complex class expression for {base}.
            llm_block, processing_time = ask_question(prompt)
            valid, reason = closed_world_reasoner(
                llm_block, kb_file, base_iri, pos_arg, neg_arg
            )
            log_message(f"Validation result ➤ valid={valid}, feedback:\n{reason}")
            if not valid:
                feedback = f"Previous attempt:\n{llm_block}\nReasoner output:\n{reason}\nPlease refine based on the Reasoner feedback."
                log_message(f"Reasoner feedback:\n{feedback}")
            attempts += 1

        # Save final LLM block + reasoner output
        out_path = os.path.join(output_folder, f"response_{base}.txt")
        with open(out_path, "w", encoding="utf-8") as f:
            if valid:
                f.write("✅ SUCCESS on attempt {}\n\n".format(attempts))
                f.write("LLM output:\n" + llm_block + "\n\n")
                f.write("Reasoner feedback:\n" + reason + "\n")
                f.write(f"\nProcessing time for o3-mini: {processing_time:.2f} seconds\n")  # Save the processing time in the output file
            else:
                f.write("❌ All {} attempts were invalid.\n\n".format(max_attempts))
                f.write("Last LLM output:\n" + llm_block + "\n\n")
                f.write("Last reasoner feedback:\n" + reason + "\n")
                f.write(f"\nProcessing time for o3-mini: {processing_time:.2f} seconds\n")  # Save the processing time in the output file
        log_message(f"\n✔ Saved final batch to {out_path}\n")

        
        
if __name__ == "__main__":
    positive_folder   = "trains/positive"
    negative_folder   = "trains/negative"
    output_folder     = "trains/responses_with_reasoner_o3_mini"
    kb_file           = "trains/trains2.owl"
    kb_file_text      = "trains/KB_trains2.txt"
    
    os.makedirs(output_folder, exist_ok=True)
    process_files(
        positive_folder,
        negative_folder,
        output_folder,
        kb_file,
        kb_file_text
    )


# In[148]:


#o3-mini family
import os
import subprocess
import openai
import time

from openai import OpenAI

# Initialize OpenAI client
client = OpenAI(api_key="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")

log_file = "debug_log.txt"
if os.path.isdir(log_file):
    os.rmdir(log_file)

def log_message(message: str):
    with open(log_file, "a", encoding="utf‑8") as f:
        f.write(message + "\n")
    print(message)

def read_text_file(path: str) -> str:
    with open(path, "r", encoding="utf‑8") as f:
        return f.read().strip()
    
def ask_question(prompt: str) -> str:
    start_time = time.time()  # Record start time
    resp = client.chat.completions.create(
        model="o3-mini",
        reasoning_effort="high",
        #messages=[{"role": "user", "content": prompt}],
        messages=[
            {"role": "system", "content": "You are a helpful Description Logic learner."},
            {"role": "user",   "content": prompt}
        ],
        store=True,
    )
    end_time = time.time()  # Record end time
    processing_time = end_time - start_time  # Calculate processing time
    text = resp.choices[0].message.content.strip()
    log_message(f"\nLLM ➤ {text}")
    # Print the processing time
    print(f"Processing time for o3-mini: {processing_time:.2f} seconds")  
    return text, processing_time


def closed_world_reasoner(
    llm_block: str,
    kb_file: str,
    base_iri: str,
    pos_list: str,
    neg_list: str
):
    """
    Calls your GenericReasonerCheck jar-with-dependencies using Pellet.
    - llm_block: the full multiline LLM output (lines “1: …” through “5: …”)
    - pos_list, neg_list: comma-separated names
    Returns (valid: bool, feedback: str).
    """
    cmd = [
        "java", "-jar",
        "target/merged-reasoner-check-1.0-SNAPSHOT.jar",
        kb_file,
        base_iri,
        "-",            # read the LLM block from stdin
        pos_list,
        neg_list
    ]
    log_message(f"\n▶ Running Pellet: {' '.join(cmd)}")
    proc = subprocess.run(
        cmd,
        input=llm_block,
        capture_output=True,
        text=True
    )
    out = proc.stdout.strip()
    err = proc.stderr.strip()
    if out:
        log_message(f"Pellet stdout ➤\n{out}")
    if err:
        log_message(f"Pellet stderr ➤\n{err}")

    #valid = (proc.returncode == 0)
    #feedback = out if out else err
    valid = (proc.returncode == 0)
     # always include both streams
    feedback_parts = []
    if out:
        feedback_parts.append(out)
    if err:
        feedback_parts.append(err)
    feedback = "\n".join(feedback_parts)

    return valid, feedback

def process_files(positive_folder, negative_folder, output_folder, kb_file, kb_file_text):
    kb_text = read_text_file(kb_file_text)

    for fname in sorted(os.listdir(positive_folder)):
        if not fname.startswith("positive_") or not fname.endswith(".txt"):
            continue
        base = fname[len("positive_"):-4]
        pos_path = os.path.join(positive_folder, fname)
        neg_path = os.path.join(negative_folder, f"negative_{base}.txt")
        if not os.path.exists(neg_path):
            continue

        # Read and clean up names for Java
        pos_names = [ln.replace("kb:", "").strip()
                     for ln in read_text_file(pos_path).splitlines() if ln.strip()]
        neg_names = [ln.replace("kb:", "").strip()
                     for ln in read_text_file(neg_path).splitlines() if ln.strip()]
        pos_arg = ",".join(pos_names)
        neg_arg = ",".join(neg_names)

        print(f"\n=== Processing batch: {base} ===")
        base_iri = input("Enter your base IRI (e.g. http://example.org/onto#): ").strip()
        if not (base_iri.endswith("#") or base_iri.endswith("/")):
            base_iri += "#"

        attempts = 0
        max_attempts = 3
        valid = False
        feedback = ""
        llm_block = ""
        processing_time = 0.0

        while attempts < max_attempts and not valid:
            prompt = f"""
Take the given ontology as the knowledge base: {kb_text}.

Use this knowledge base to extract complex class expressions for the given positive and negative examples. A complex class expression is an OWL class expression that consists of the classes and properties that apply to the positive examples but not to the negative examples.
Use Manchester syntax for the complex class expressions. 
For example:
If the positive examples are:
(Dino, Luigi, Mauro, Francesco, Giuseppe)

And the negative examples are:
(Antonella, Giovanna, Maria, Marisella, Milly, Nella, NonnaLina, Ombretta, Rosanna, Serena, Valentina, Luca)

Then the complex class expression generated by DL-Learner is(first 5 are shown):
1: Male and (hasSibling some Thing) (accuracy 100%, length 5, depth 1)
2: Male and ((not (Male)) or (hasSibling some Thing)) (accuracy 100%, length 8, depth 1)
3: Male and ((hasChild some Thing) or (hasSibling some Thing)) (accuracy 100%, length 9, depth 1)
4: Male and ((hasSibling some Thing) or (hasSibling some Thing)) (accuracy 100%, length 9, depth 1)
5: Male and ((hasSibling some Thing) or (hasParent max 1 Thing)) (accuracy 100%, length 10, depth 1)

All the class expressions are generated using the Closed World Assumption of the knowledge base.

Now, perform a logical reasoning based on the knowledge base to find the shortest complex class expressions for the following examples:

Positive examples: {pos_arg}
Negative examples: {neg_arg}
Generate the complex class expression for {base}.
{feedback} 
Don't give me any description just the shortest complex class expressions(upto first 5) and follow the example format:
"""
            #Generate the complex class expression for {base}.
            llm_block, processing_time = ask_question(prompt)
            valid, reason = closed_world_reasoner(
                llm_block, kb_file, base_iri, pos_arg, neg_arg
            )
            log_message(f"Validation result ➤ valid={valid}, feedback:\n{reason}")
            if not valid:
                feedback = f"Previous attempt:\n{llm_block}\nReasoner output:\n{reason}\nPlease refine based on the Reasoner feedback."
                log_message(f"Reasoner feedback:\n{feedback}")
            attempts += 1

        # Save final LLM block + reasoner output
        out_path = os.path.join(output_folder, f"response_{base}.txt")
        with open(out_path, "w", encoding="utf-8") as f:
            if valid:
                f.write("✅ SUCCESS on attempt {}\n\n".format(attempts))
                f.write("LLM output:\n" + llm_block + "\n\n")
                f.write("Reasoner feedback:\n" + reason + "\n")
                f.write(f"\nProcessing time for o3-mini: {processing_time:.2f} seconds\n")  # Save the processing time in the output file
            else:
                f.write("❌ All {} attempts were invalid.\n\n".format(max_attempts))
                f.write("Last LLM output:\n" + llm_block + "\n\n")
                f.write("Last reasoner feedback:\n" + reason + "\n")
                f.write(f"\nProcessing time for o3-mini: {processing_time:.2f} seconds\n")  # Save the processing time in the output file
        log_message(f"\n✔ Saved final batch to {out_path}\n")

        
        
if __name__ == "__main__":
    positive_folder   = "yinyang_examples/positive"
    negative_folder   = "yinyang_examples/negative"
    output_folder     = "yinyang_examples/responses_with_reasoner_o3_mini"
    kb_file           = "yinyang_examples/basicFamily.owl"
    kb_file_text      = "yinyang_examples/KB_family.txt"

    os.makedirs(output_folder, exist_ok=True)
    process_files(
        positive_folder,
        negative_folder,
        output_folder,
        kb_file,
        kb_file_text
    )


# In[36]:


#o3-mini family-benchmark
import os
import subprocess
import openai
import time

from openai import OpenAI

# Initialize OpenAI client
client = OpenAI(api_key="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")

log_file = "debug_log.txt"
if os.path.isdir(log_file):
    os.rmdir(log_file)

def log_message(message: str):
    with open(log_file, "a", encoding="utf‑8") as f:
        f.write(message + "\n")
    print(message)

def read_text_file(path: str) -> str:
    with open(path, "r", encoding="utf‑8") as f:
        return f.read().strip()
    
def ask_question(prompt: str) -> str:
    start_time = time.time()  # Record start time
    resp = client.chat.completions.create(
        model="o3-mini",
        reasoning_effort="high",
        #messages=[{"role": "user", "content": prompt}],
        messages=[
            {"role": "system", "content": "You are a helpful Description Logic learner."},
            {"role": "user",   "content": prompt}
        ],
        store=True,
    )
    end_time = time.time()  # Record end time
    processing_time = end_time - start_time  # Calculate processing time
    text = resp.choices[0].message.content.strip()
    log_message(f"\nLLM ➤ {text}")
    # Print the processing time
    print(f"Processing time for o3-mini: {processing_time:.2f} seconds")  
    return text, processing_time


def closed_world_reasoner(
    llm_block: str,
    kb_file: str,
    base_iri: str,
    pos_list: str,
    neg_list: str
):
    """
    Calls your GenericReasonerCheck jar-with-dependencies using Pellet.
    - llm_block: the full multiline LLM output (lines “1: …” through “5: …”)
    - pos_list, neg_list: comma-separated names
    Returns (valid: bool, feedback: str).
    """
    cmd = [
        "java", "-jar",
        "target/merged-reasoner-check-1.0-SNAPSHOT.jar",
        kb_file,
        base_iri,
        "-",            # read the LLM block from stdin
        pos_list,
        neg_list
    ]
    log_message(f"\n▶ Running Pellet: {' '.join(cmd)}")
    proc = subprocess.run(
        cmd,
        input=llm_block,
        capture_output=True,
        text=True
    )
    out = proc.stdout.strip()
    err = proc.stderr.strip()
    if out:
        log_message(f"Pellet stdout ➤\n{out}")
    if err:
        log_message(f"Pellet stderr ➤\n{err}")

    #valid = (proc.returncode == 0)
    #feedback = out if out else err
    valid = (proc.returncode == 0)
     # always include both streams
    feedback_parts = []
    if out:
        feedback_parts.append(out)
    if err:
        feedback_parts.append(err)
    feedback = "\n".join(feedback_parts)

    return valid, feedback

def process_files(positive_folder, negative_folder, output_folder, kb_file, kb_file_text):
    kb_text = read_text_file(kb_file_text)

    for fname in sorted(os.listdir(positive_folder)):
        if not fname.startswith("positive_") or not fname.endswith(".txt"):
            continue
        base = fname[len("positive_"):-4]
        pos_path = os.path.join(positive_folder, fname)
        neg_path = os.path.join(negative_folder, f"negative_{base}.txt")
        if not os.path.exists(neg_path):
            continue

        # Read and clean up names for Java, stripping either 'kb:' or 'ex:' prefixes
        pos_names = [
            ln.strip()
              .replace("kb:", "")
              .replace("ex:", "")
            for ln in read_text_file(pos_path).splitlines()
            if ln.strip()
        ]
        neg_names = [
            ln.strip()
              .replace("kb:", "")
              .replace("ex:", "")
            for ln in read_text_file(neg_path).splitlines()
            if ln.strip()
        ]

        pos_arg = ",".join(pos_names)
        neg_arg = ",".join(neg_names)

        print(f"\n=== Processing batch: {base} ===")
        base_iri = input("Enter your base IRI (e.g. http://example.org/onto#): ").strip()
        if not (base_iri.endswith("#") or base_iri.endswith("/")):
            base_iri += "#"

        attempts = 0
        max_attempts = 3
        valid = False
        feedback = ""
        llm_block = ""
        processing_time = 0.0

        while attempts < max_attempts and not valid:
            prompt = f"""
Take the given ontology as the knowledge base: {kb_text}.

Use this knowledge base to extract complex class expressions for the given positive and negative examples. A complex class expression is an OWL class expression that consists of the classes and properties that apply to the positive examples but not to the negative examples.
Use Manchester syntax for the complex class expressions. 
For example:
If the positive examples are:
(F2M13, F2M18, F2M11, F2M32, F3M44, F3M45, F5M64, F6M71, F6M81, F6M90, F6M100, F6M92, F7M113, F7M117, F7M115, F7M125, F7M123, F7M131, F9M151, F9M153, F9M159, F9M166, F9M162, F9M157, F9M167, F10M173, F10M183, F10M184, F10M188, F10M199)

And the negative examples are:
(F10M196, F1M8, F7F103, F3F41, F1M1, F9F164, F9M149, F9M147, F9F158, F2F12, F1F5, F6M88, F7M104, F7M109, F7M120, F6F83, F6M78, F3M47, F10F174, F6F76, F2F26, F6F89, F3M50, F3F42, F6F79, F10M194, F2F19, F2F24, F9F154, F4F58)

Then the complex class expression generated by DL-Learner is(first 5 are shown):
1: Male and (hasSibling some Thing) (pred. acc.: 100.00%, F-measure: 100.00%)
2: Male and (hasParent some Thing) (pred. acc.: 95.00%, F-measure: 95.24%)
3: Male (pred. acc.: 80.00%, F-measure: 83.33%)
4: not (Female) (pred. acc.: 80.00%, F-measure: 83.33%)
5: Person and (not (Female)) (pred. acc.: 80.00%, F-measure: 83.33%)

All the class expressions are generated using the Closed World Assumption of the knowledge base.

Now, perform a logical reasoning based on the knowledge base to find the shortest complex class expressions for the following examples:

Positive examples: {pos_arg}
Negative examples: {neg_arg}
{feedback} 
Don't give me any description just the shortest complex class expressions(upto first 5) and follow the example format:
"""
            #Generate the complex class expression for {base}.
            llm_block, processing_time = ask_question(prompt)
            valid, reason = closed_world_reasoner(
                llm_block, kb_file, base_iri, pos_arg, neg_arg
            )
            log_message(f"Validation result ➤ valid={valid}, feedback:\n{reason}")
            if not valid:
                feedback = f"Previous attempt:\n{llm_block}\nReasoner output:\n{reason}\nPlease refine based on the Reasoner feedback."
                log_message(f"Reasoner feedback:\n{feedback}")
            attempts += 1

        # Save final LLM block + reasoner output
        out_path = os.path.join(output_folder, f"response_{base}.txt")
        with open(out_path, "w", encoding="utf-8") as f:
            if valid:
                f.write("✅ SUCCESS on attempt {}\n\n".format(attempts))
                f.write("LLM output:\n" + llm_block + "\n\n")
                f.write("Reasoner feedback:\n" + reason + "\n")
                f.write(f"\nProcessing time for o3-mini: {processing_time:.2f} seconds\n")  # Save the processing time in the output file
            else:
                f.write("❌ All {} attempts were invalid.\n\n".format(max_attempts))
                f.write("Last LLM output:\n" + llm_block + "\n\n")
                f.write("Last reasoner feedback:\n" + reason + "\n")
                f.write(f"\nProcessing time for o3-mini: {processing_time:.2f} seconds\n")  # Save the processing time in the output file
        log_message(f"\n✔ Saved final batch to {out_path}\n")

        
        
if __name__ == "__main__":
    positive_folder   = "family-benchmark/positive_copy"
    negative_folder   = "family-benchmark/negative_copy"
    output_folder     = "family-benchmark/responses_with_reasoner_o3_mini_without_basename"
    kb_file           = "family-benchmark/family-benchmark.owl"
    kb_file_text      = "family-benchmark/KB_family-benchmark.txt"

    os.makedirs(output_folder, exist_ok=True)
    process_files(
        positive_folder,
        negative_folder,
        output_folder,
        kb_file,
        kb_file_text
    )


# In[162]:


#gpt-4o/o3-mini Changed gender
import os
import subprocess
import openai

from openai import OpenAI

# Initialize OpenAI client
client = OpenAI(api_key="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")

log_file = "debug_log.txt"
if os.path.isdir(log_file):
    os.rmdir(log_file)

def log_message(message: str):
    with open(log_file, "a", encoding="utf‑8") as f:
        f.write(message + "\n")
    print(message)

def read_text_file(path: str) -> str:
    with open(path, "r", encoding="utf‑8") as f:
        return f.read().strip()

def ask_question(prompt: str) -> str:
    start_time = time.time()  # Record start time
    resp = client.chat.completions.create(
        model="gpt-4o",
        #messages=[{"role": "user", "content": prompt}],
        messages=[
            {"role": "system", "content": "You are a helpful Description Logic learner."},
            {"role": "user",   "content": prompt}
        ],
        temperature=0,
        top_p=1
    )
    end_time = time.time()  # Record end time
    processing_time = end_time - start_time  # Calculate processing time
    text = resp.choices[0].message.content.strip()
    log_message(f"\nLLM ➤ {text}")
    # Print the processing time
    #print(f"Processing time for o3-mini: {processing_time:.2f} seconds") 
    print(f"Processing time for gpt-4o: {processing_time:.2f} seconds") 
    return text, processing_time


def closed_world_reasoner(
    llm_block: str,
    kb_file: str,
    base_iri: str,
    pos_list: str,
    neg_list: str
):
    """
    Calls your GenericReasonerCheck jar-with-dependencies using Pellet.
    - llm_block: the full multiline LLM output (lines “1: …” through “5: …”)
    - pos_list, neg_list: comma-separated names
    Returns (valid: bool, feedback: str).
    """
    cmd = [
        "java", "-jar",
        "target/merged-reasoner-check-1.0-SNAPSHOT.jar",
        kb_file,
        base_iri,
        "-",            # read the LLM block from stdin
        pos_list,
        neg_list
    ]
    log_message(f"\n▶ Running Pellet: {' '.join(cmd)}")
    proc = subprocess.run(
        cmd,
        input=llm_block,
        capture_output=True,
        text=True
    )
    out = proc.stdout.strip()
    err = proc.stderr.strip()
    if out:
        log_message(f"Pellet stdout ➤\n{out}")
    if err:
        log_message(f"Pellet stderr ➤\n{err}")

    #valid = (proc.returncode == 0)
    #feedback = out if out else err
    valid = (proc.returncode == 0)
     # always include both streams
    feedback_parts = []
    if out:
        feedback_parts.append(out)
    if err:
        feedback_parts.append(err)
    feedback = "\n".join(feedback_parts)

    return valid, feedback

def process_files(positive_folder, negative_folder, output_folder, kb_file, kb_file_text):
    kb_text = read_text_file(kb_file_text)

    for fname in sorted(os.listdir(positive_folder)):
        if not fname.startswith("positive_") or not fname.endswith(".txt"):
            continue
        base = fname[len("positive_"):-4]
        pos_path = os.path.join(positive_folder, fname)
        neg_path = os.path.join(negative_folder, f"negative_{base}.txt")
        if not os.path.exists(neg_path):
            continue

        # Read and clean up names for Java
        pos_names = [ln.replace("kb:", "").strip()
                     for ln in read_text_file(pos_path).splitlines() if ln.strip()]
        neg_names = [ln.replace("kb:", "").strip()
                     for ln in read_text_file(neg_path).splitlines() if ln.strip()]
        pos_arg = ",".join(pos_names)
        neg_arg = ",".join(neg_names)

        print(f"\n=== Processing batch: {base} ===")
        base_iri = input("Enter your base IRI (e.g. http://example.org/onto#): ").strip()
        if not (base_iri.endswith("#") or base_iri.endswith("/")):
            base_iri += "#"

        attempts = 0
        max_attempts = 3
        valid = False
        feedback = ""
        llm_block = ""
        processing_time = 0.0

        while attempts < max_attempts and not valid:
            prompt = f"""
Take the given ontology as the knowledge base: {kb_text}.

Use this knowledge base to extract complex class expressions for the given positive and negative examples. A complex class expression is an OWL class expression that consists of the classes and properties that apply to the positive examples but not to the negative examples.
Use Manchester syntax for the complex class expressions. 
For example:
If the positive examples are:
(Dino, Luigi, Mauro, Francesco, Giuseppe)

And the negative examples are:
(Antonella, Giovanna, Maria, Marisella, Milly, Nella, NonnaLina, Ombretta, Rosanna, Serena, Valentina, Luca)

Then the complex class expression generated by DL-Learner is(first 5 are shown):
1: Female and (hasSibling some Thing) (accuracy 100%, length 5, depth 1)
2: Female and ((not (Female)) or (hasSibling some Thing)) (accuracy 100%, length 8, depth 1)
3: Female and ((hasChild some Thing) or (hasSibling some Thing)) (accuracy 100%, length 9, depth 1)
4: Female and ((hasSibling some Thing) or (hasSibling some Thing)) (accuracy 100%, length 9, depth 1)
5: Female and ((hasSibling some Thing) or (hasParent max 1 Thing)) (accuracy 100%, length 10, depth 1)

All the class expressions are generated using the Closed World Assumption of the knowledge base.

Now, perform a logical reasoning based on the knowledge base to find the shortest complex class expressions for the following examples:

Positive examples: {pos_arg}
Negative examples: {neg_arg}
{feedback} 
Don't give me any description just the shortest complex class expressions(upto first 5) and follow the example format:
"""
            #Generate the complex class expression for {base}.
            llm_block, processing_time = ask_question(prompt)
            valid, reason = closed_world_reasoner(
                llm_block, kb_file, base_iri, pos_arg, neg_arg
            )
            log_message(f"Validation result ➤ valid={valid}, feedback:\n{reason}")
            if not valid:
                feedback = f"Previous attempt:\n{llm_block}\nReasoner output:\n{reason}\nPlease refine based on the Reasoner feedback."
                log_message(f"Reasoner feedback:\n{feedback}")
            attempts += 1

        # Save final LLM block + reasoner output
        out_path = os.path.join(output_folder, f"response_{base}.txt")
        with open(out_path, "w", encoding="utf-8") as f:
            if valid:
                f.write("✅ SUCCESS on attempt {}\n\n".format(attempts))
                f.write("LLM output:\n" + llm_block + "\n\n")
                f.write("Reasoner feedback:\n" + reason + "\n")
                #f.write(f"\nProcessing time for o3-mini: {processing_time:.2f} seconds\n")  # Save the processing time in the output file
                f.write(f"\nProcessing time for gpt-4o: {processing_time:.2f} seconds\n")  # Save the processing time in the output file
            else:
                f.write("❌ All {} attempts were invalid.\n\n".format(max_attempts))
                f.write("Last LLM output:\n" + llm_block + "\n\n")
                f.write("Last reasoner feedback:\n" + reason + "\n")
                #f.write(f"\nProcessing time for o3-mini: {processing_time:.2f} seconds\n")  # Save the processing time in the output file
                f.write(f"\nProcessing time for gpt-4o: {processing_time:.2f} seconds\n")  # Save the processing time in the output file
        log_message(f"\n✔ Saved final batch to {out_path}\n")

        
        
if __name__ == "__main__":
    positive_folder   = "yinyang_examples/Changed_gender_family/positive"
    negative_folder   = "yinyang_examples/Changed_gender_family/negative"
    output_folder     = "yinyang_examples/Changed_gender_family/responses_with_reasoner_without_basename"
    kb_file           = "yinyang_examples/Changed_gender_family/basicFamily_changedGender.owl"
    kb_file_text      = "yinyang_examples/Changed_gender_family/KB_family_changed_gender.txt"

    os.makedirs(output_folder, exist_ok=True)
    process_files(
        positive_folder,
        negative_folder,
        output_folder,
        kb_file,
        kb_file_text
    )


# In[168]:


# gpt-4o/o3-mini family_changed_relations
# Daughter -> Son
# Father -> Mother 
# GrandFather -> GrandMother 
# GrandMother -> GrandFather
# GrandParent -> Uncle
# Offspring -> Aunt
# Parent -> Children 
# Sibling -> Friend
# Sister -> Brother
#gpt-o3-mini 
import os
import subprocess
import openai

from openai import OpenAI

# Initialize OpenAI client
client = OpenAI(api_key="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")

log_file = "debug_log.txt"
if os.path.isdir(log_file):
    os.rmdir(log_file)

def log_message(message: str):
    with open(log_file, "a", encoding="utf‑8") as f:
        f.write(message + "\n")
    print(message)

def read_text_file(path: str) -> str:
    with open(path, "r", encoding="utf‑8") as f:
        return f.read().strip()
    
def ask_question(prompt: str) -> str:
    start_time = time.time()  # Record start time
    resp = client.chat.completions.create(
        model="gpt-4o",
        #messages=[{"role": "user", "content": prompt}],
        messages=[
            {"role": "system", "content": "You are a helpful Description Logic learner."},
            {"role": "user",   "content": prompt}
        ],
        temperature=0,
        top_p=1
    )
    end_time = time.time()  # Record end time
    processing_time = end_time - start_time  # Calculate processing time
    text = resp.choices[0].message.content.strip()
    log_message(f"\nLLM ➤ {text}")
    # Print the processing time
    #print(f"Processing time for o3-mini: {processing_time:.2f} seconds") 
    print(f"Processing time for gpt-4o: {processing_time:.2f} seconds") 
    return text, processing_time


def closed_world_reasoner(
    llm_block: str,
    kb_file: str,
    base_iri: str,
    pos_list: str,
    neg_list: str
):
    """
    Calls your GenericReasonerCheck jar-with-dependencies using Pellet.
    - llm_block: the full multiline LLM output (lines “1: …” through “5: …”)
    - pos_list, neg_list: comma-separated names
    Returns (valid: bool, feedback: str).
    """
    cmd = [
        "java", "-jar",
        "target/merged-reasoner-check-1.0-SNAPSHOT.jar",
        kb_file,
        base_iri,
        "-",            # read the LLM block from stdin
        pos_list,
        neg_list
    ]
    log_message(f"\n▶ Running Pellet: {' '.join(cmd)}")
    proc = subprocess.run(
        cmd,
        input=llm_block,
        capture_output=True,
        text=True
    )
    out = proc.stdout.strip()
    err = proc.stderr.strip()
    if out:
        log_message(f"Pellet stdout ➤\n{out}")
    if err:
        log_message(f"Pellet stderr ➤\n{err}")

    #valid = (proc.returncode == 0)
    #feedback = out if out else err
    valid = (proc.returncode == 0)
     # always include both streams
    feedback_parts = []
    if out:
        feedback_parts.append(out)
    if err:
        feedback_parts.append(err)
    feedback = "\n".join(feedback_parts)

    return valid, feedback

def process_files(positive_folder, negative_folder, output_folder, kb_file, kb_file_text):
    kb_text = read_text_file(kb_file_text)

    for fname in sorted(os.listdir(positive_folder)):
        if not fname.startswith("positive_") or not fname.endswith(".txt"):
            continue
        base = fname[len("positive_"):-4]
        pos_path = os.path.join(positive_folder, fname)
        neg_path = os.path.join(negative_folder, f"negative_{base}.txt")
        if not os.path.exists(neg_path):
            continue

        # Read and clean up names for Java
        pos_names = [ln.replace("kb:", "").strip()
                     for ln in read_text_file(pos_path).splitlines() if ln.strip()]
        neg_names = [ln.replace("kb:", "").strip()
                     for ln in read_text_file(neg_path).splitlines() if ln.strip()]
        pos_arg = ",".join(pos_names)
        neg_arg = ",".join(neg_names)

        print(f"\n=== Processing batch: {base} ===")
        base_iri = input("Enter your base IRI (e.g. http://example.org/onto#): ").strip()
        if not (base_iri.endswith("#") or base_iri.endswith("/")):
            base_iri += "#"

        attempts = 0
        max_attempts = 3
        valid = False
        feedback = ""
        llm_block = ""
        processing_time = 0.0

        while attempts < max_attempts and not valid:
            prompt = f"""
Take the given ontology as the knowledge base: {kb_text}.

Use this knowledge base to extract complex class expressions for the given positive and negative examples. A complex class expression is an OWL class expression that consists of the classes and properties that apply to the positive examples but not to the negative examples.
Use Manchester syntax for the complex class expressions. 
For example:
If the positive examples are:
(Dino, Luigi, Mauro, Francesco, Giuseppe)

And the negative examples are:
(Antonella, Giovanna, Maria, Marisella, Milly, Nella, NonnaLina, Ombretta, Rosanna, Serena, Valentina, Luca)

Then the complex class expression generated by DL-Learner is(first 5 are shown):
1: Male and (hasSibling some Thing) (accuracy 100%, length 5, depth 1)
2: Male and ((not (Male)) or (hasSibling some Thing)) (accuracy 100%, length 8, depth 1)
3: Male and ((hasChild some Thing) or (hasSibling some Thing)) (accuracy 100%, length 9, depth 1)
4: Male and ((hasSibling some Thing) or (hasSibling some Thing)) (accuracy 100%, length 9, depth 1)
5: Male and ((hasSibling some Thing) or (hasParent max 1 Thing)) (accuracy 100%, length 10, depth 1)

All the class expressions are generated using the Closed World Assumption of the knowledge base.

Now, perform a logical reasoning based on the knowledge base to find the shortest complex class expressions for the following examples:

Positive examples: {pos_arg}
Negative examples: {neg_arg}
Generate the complex class expression for {base}.
{feedback} 
Don't give me any description just the shortest complex class expressions(upto first 5) and follow the example format:
"""
            llm_block, processing_time = ask_question(prompt)
            valid, reason = closed_world_reasoner(
                llm_block, kb_file, base_iri, pos_arg, neg_arg
            )
            log_message(f"Validation result ➤ valid={valid}, feedback:\n{reason}")
            if not valid:
                feedback = f"Previous attempt:\n{llm_block}\nReasoner output:\n{reason}\nPlease refine based on the Reasoner feedback."
                log_message(f"Reasoner feedback:\n{feedback}")
            attempts += 1

        # Save final LLM block + reasoner output
        out_path = os.path.join(output_folder, f"response_{base}.txt")
        with open(out_path, "w", encoding="utf-8") as f:
            if valid:
                f.write("✅ SUCCESS on attempt {}\n\n".format(attempts))
                f.write("LLM output:\n" + llm_block + "\n\n")
                f.write("Reasoner feedback:\n" + reason + "\n")
                #f.write(f"\nProcessing time for o3-mini: {processing_time:.2f} seconds\n")  # Save the processing time in the output file
                f.write(f"\nProcessing time for gpt-4o: {processing_time:.2f} seconds\n")  # Save the processing time in the output file
            else:
                f.write("❌ All {} attempts were invalid.\n\n".format(max_attempts))
                f.write("Last LLM output:\n" + llm_block + "\n\n")
                f.write("Last reasoner feedback:\n" + reason + "\n")
                #f.write(f"\nProcessing time for o3-mini: {processing_time:.2f} seconds\n")  # Save the processing time in the output file
                f.write(f"\nProcessing time for gpt-4o: {processing_time:.2f} seconds\n")  # Save the processing time in the output file
        log_message(f"\n✔ Saved final batch to {out_path}\n")

        
        
if __name__ == "__main__":
    positive_folder   = "yinyang_examples/positive_changed_relations"
    negative_folder   = "yinyang_examples/negative_changed_relations"
    output_folder     = "yinyang_examples/responses_with_reasoner_changed_relations"
    kb_file           = "yinyang_examples/basicFamily.owl"
    kb_file_text      = "yinyang_examples/KB_family.txt"

    os.makedirs(output_folder, exist_ok=True)
    process_files(
        positive_folder,
        negative_folder,
        output_folder,
        kb_file,
        kb_file_text
    )


# In[37]:


import os
import re

def summary_result(resp_dir: str, summary_path: str):
    success_map = {}
    fail_map = {}
    
    for fn in sorted(os.listdir(resp_dir)):
        if not (fn.startswith("response_") and fn.endswith(".txt")):
            continue

        path = os.path.join(resp_dir, fn)
        first = None
        try:
            with open(path, "r", encoding="utf-8", errors="replace") as f:
                for line in f:
                    line = line.strip()
                    if line:
                        first = line
                        break
        except Exception as e:
            print(f"⚠️ Skipping {fn}: {e}")
            continue

        if not first:
            continue

        if first.startswith("✅"):
            # e.g. "✅ SUCCESS on attempt 2"
            m = re.search(r"on attempt (\d+)", first)
            attempt = int(m.group(1)) if m else None
            success_map[fn] = attempt
        elif first.startswith("❌"):
            # e.g. "❌ All 3 attempts were invalid."
            m = re.search(r"All (\d+) attempts", first)
            attempts = int(m.group(1)) if m else None
            fail_map[fn] = attempts
        else:
            # neither success nor failure marker
            continue

    # write summary
    with open(summary_path, "w", encoding="utf-8") as out:
        out.write(f"Total Successes: {len(success_map)}\n")
        out.write(f"Total Failures:  {len(fail_map)}\n\n")
        out.write("Details:\n")
        for fn, att in success_map.items():
            out.write(f"{fn}: ✅ success on attempt {att or '?'}\n")

    print(f"Wrote summary to {summary_path}")

if __name__ == "__main__":
    resp_dir    = "family-benchmark/responses_with_reasoner_o3_mini_without_basename"
    summary_out = os.path.join(resp_dir, "summary_results.txt")
    os.makedirs(resp_dir, exist_ok=True)
    summary_result(resp_dir, summary_out) 


# In[60]:


# Cell 1: Configuration
root_dir = "trains/responses_with_reasoner_o3_mini"  # <-- adjust as needed

# Cell 2: Extraction Functions
import os, re
from statistics import mean
import pandas as pd
from IPython.display import display, Markdown

def extract_times_from_file(filepath):
    """
    Read a file with 'latin-1' fallback, return all processing times found.
    """
    times = []
    pattern = re.compile(r'Processing time.*?:\s*([\d.]+)\s*seconds', re.IGNORECASE)
    with open(filepath, 'r', encoding='utf-8', errors='replace') as f:
        for line in f:
            m = pattern.search(line)
            if m:
                times.append(float(m.group(1)))
    return times

def compute_times_dataframe(root_dir, extensions=(".txt",)):
    records = []
    all_times = []
    
    for dirpath, _, filenames in os.walk(root_dir):
        for fname in filenames:
            if fname.lower().endswith(extensions):
                fullpath = os.path.join(dirpath, fname)
                times = extract_times_from_file(fullpath)
                if times:
                    records.append({
                        "file": os.path.relpath(fullpath, root_dir),
                        "count": len(times),
                        "avg_time_s": round(mean(times), 2)
                    })
                    all_times.extend(times)
    
    df = pd.DataFrame(records)
    overall_avg = round(mean(all_times), 2) if all_times else None
    return df, overall_avg

# Cell 3: Run Analysis and Display
df_times, overall_avg = compute_times_dataframe(root_dir)

# Cell 4: Save Overall Average to File
output_file = os.path.join(root_dir, "overall_avg_time.txt") # <-- adjust filename/path if desired

if overall_avg is not None:
    with open(output_file, "w", encoding="utf-8") as f:
        f.write(f"{overall_avg:.2f} seconds\n")
    print(f"Saved overall average processing time to '{output_file}'")
else:
    print("No average processing time to save.")

